# AID1905 第二次周测题

## 一、选择题

1. 下列哪项不是Linux操作系统的特征（C）

> A. Linux操作系统是开源的
>
> B. Linux操作系统有内核，文件系统，shell，应用构成
>
> C. Linux图形化界面和网络功能的支持较差
>
> D. Linux操作系统是一种常用的服务器系统

2. 关于绝对路径和相对路径的说法正确的是（AB）

> A. 绝对路径是从根目录开始查找文件
>
> B. 相对路径是从当前位置查找文件
>
> C. 使用绝对路径比相对路径方便
>
> D. 使用相对路径比绝对路径方便

3. 关于二叉树的遍历，以下选项中描述错误的是BD

> A. 前序遍历是先遍历左子树，然后访问根结点，最后遍历右子树
>
> B. 后序遍历二叉树的过程是一个递归的过程
>
> C.  二叉树的遍历是指不重复地访问二叉树中的所有结点
>
> D. 二叉树的遍历可以分为三种：前序遍历、中序遍历、后序遍历

4. 下面四个选项, 关于with语句描述正确的是( D)

> A. 任何对象都能用with语句进行管理
>
> B. open 函数返回的文件流对象可以用with语句中进行管理
>
> C. with 语句主要用于容易引发异常的异常处理中
>
> D. 在 with 语句内部创建的变量,在with语句之后无法再次访问

5. 下列说法不正确的是（A,B）

> A. 多进程并发，多线程并发，协程并发原理一样，都是每个客户端创建一个分支进行处
>
> B. select，poll，epoll都是IO多路复用的方法
>
> C. socketserver模块可以实现多进程和多线程的并发模型
>
> D. 协程拥有很好的处理IO并发请求的能力

## 二、简答题

1. 写出下列命令的作用

> ```
> mkdir：创建文件夹
> touch：创建文档
> vi:进入编辑模式
> rm：删除
> cp：复制
> ```

2. 请阐述进程、线程、协程，以及他们的应用场景。

> ```
> 进程:为了更好的利用CPU资源。
> 线程:降低上下文切换的消耗，提高并发性。
> 协程:在线程中实现调度，补充线程在IO上的性能缺陷。 
> ```

3. 请阐述七层模型、四层模型，说明其作用及并列举对应的协议。

> ```
> 七层模型
> 应用层:提供用户服务,实现具体功能
> 表示层:数据的压缩优化
> 会话层:建立用户连接,选择传输服务
> 传输层:提供传输服务 
> 网络层:路由选择,网络连接
> 链路层:数据交换和发送
> 物理层:数据传输的硬件保证,网卡接口和传输
> 
> 四层模型
> 应用层:TFTP
> 传输层:TCP,UDP
> 网络层:IP
> 网络接口:IEEE,PDDI
> 
> ```

4. 请使用正则匹配出邮箱及手机号

> ```
> import re
> m= r'([\w]+(\.[\w]+)*@[\w]+(\.[\w])+)'
> j='154256216@qq.com'
> f=re.compile(m,j)
> 
> 
> re.findall
> v=r'(^[1][3,4,5,7,8][0-9]{9}$)'
> s=13526849888
> f=re.findall(v,s)
> 
> ```

## 三、编程题

1. 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

   ```python
   # -*- coding:utf-8 -*-
   class Solution:
       def jumpFloorII(self, number):
        
   ```

2. 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为`We%20Are%20Happy`。

   ```python
   # -*- coding:utf-8 -*-
   class Solution:
       # s 源字符串
       def replaceSpace(self, s):
           # class Solution {
   
           
   ```
3.  请用代码实现`TCP`或`UDP`的`Socket`通信

   ```python
   TCP
   from socket import*
s = socket()
   s.bind(('0.0.0.0', 5555))
   s.listen(5)
   connfd, addr = s.accept()
   data = connfd.recv()
   connfd.close()
   s.close()
   
   UDP
   from socket import *
   s = socket(AF_INET,SOCK_DGRAM)
   s.bind(('127.0.0.1',5555))
   data,addr = s.recvfrom()
   s.sendto(b'Thanks',addr)
   s.close()
   ```
   
   